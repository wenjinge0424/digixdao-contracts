{"Token":{"code":"0x6060604052610337806100126000396000f3606060405236156100565760e060020a6000350463095ea7b3811461005857806318160ddd146100c357806323b872dd146100cc57806370a08231146100e8578063a9059cbb1461010e578063dd62ed3e14610127575b005b61010460043560243533600160a060020a03908116600081815260016020908152604080832094871680845294825282208590556060858152919392917f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b9259190a35060015b92915050565b61010460025481565b610104600435602435604435600060003411156101e257610002565b600160a060020a03600435166000908152602081905260409020545b6060908152602090f35b6101046004356024356000600034111561015b57610002565b610104600435602435600160a060020a038083166000908152600160209081526040808320938516835292905220546100bd565b33600160a060020a03168152602081905260408120548290108015906101815750600082115b156101dd57604080822080548490039055600160a060020a03808516808452918320805485019055606084815233909116907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef90602090a35060015b6100bd565b600160a060020a038416815260208190526040812054829010801590610226575060016020908152604080832033600160a060020a03168452909152812054829010155b80156102325750600082115b1561033057816000600050600085600160a060020a03168152602001908152602001600020600082828250540192505081905550816000600050600086600160a060020a03168152602001908152602001600020600082828250540392505081905550816001600050600086600160a060020a03168152602001908152602001600020600050600033600160a060020a0316815260200190815260200160002060008282825054039250508190555082600160a060020a031684600160a060020a03167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040518082815260200191505060405180910390a35060015b939250505056","info":{"source":"/// @title DigixDAO Token Contract.\n\ncontract TokenInterface {\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n\n    /// @return total amount of tokens\n    uint256 public totalSupply;\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return The balance\n    function balanceOf(address _owner) constant returns (uint256 balance);\n\n    /// @notice send `_value` tokens to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of tokens to be transfered\n    /// @return Whether the transfer was successful or not\n    function transfer(address _to, uint256 _value) returns (bool success);\n\n    /// @notice send `_value` tokens to `_to` from `_from` on the condition it is approved by `_from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of tokens to be transfered\n    /// @return Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens on its behalf\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of tokens to be approved for transfer\n    /// @return Whether the approval was successful or not\n    function approve(address _spender, uint256 _value) returns (bool success);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens of _owner that _spender is allowed to spend\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract Token is TokenInterface {\n\n  modifier noEther() {if (msg.value > 0) throw; _}\n\n  function transfer(address _to, uint256 _value) noEther returns (bool success) {\n    if (balances[msg.sender] >= _value && _value > 0) {\n      balances[msg.sender] -= _value;\n      balances[_to] += _value;\n      Transfer(msg.sender, _to, _value);\n      success = true;\n    } else {\n      success = false;\n    }\n    return success;\n  }\n\n  function transferFrom(address _from, address _to, uint256 _value) noEther returns (bool success) {\n    if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n      balances[_to] += _value;\n      balances[_from] -= _value;\n      allowed[_from][msg.sender] -= _value;\n      Transfer(_from, _to, _value);\n      success = true;\n    } else {\n      success = false;\n    }\n    return success;\n  }\n\n  function approve(address _spender, uint256 _value) returns (bool success) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  function balanceOf(address _owner) constant returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n    return allowed[_owner][_spender];\n  }\n}\n","language":"Solidity","languageVersion":"0.2.2","compilerVersion":"0.2.2","compilerOptions":"--bin --abi --userdoc --devdoc --add-std --optimize -o /var/folders/k3/0rzjczt16cg_0k4b9drzr6nm0000gn/T/solc017761134","abiDefinition":[{"constant":false,"inputs":[{"name":"_spender","type":"address"},{"name":"_value","type":"uint256"}],"name":"approve","outputs":[{"name":"success","type":"bool"}],"type":"function"},{"constant":true,"inputs":[],"name":"totalSupply","outputs":[{"name":"","type":"uint256"}],"type":"function"},{"constant":false,"inputs":[{"name":"_from","type":"address"},{"name":"_to","type":"address"},{"name":"_value","type":"uint256"}],"name":"transferFrom","outputs":[{"name":"success","type":"bool"}],"type":"function"},{"constant":true,"inputs":[{"name":"_owner","type":"address"}],"name":"balanceOf","outputs":[{"name":"balance","type":"uint256"}],"type":"function"},{"constant":false,"inputs":[{"name":"_to","type":"address"},{"name":"_value","type":"uint256"}],"name":"transfer","outputs":[{"name":"success","type":"bool"}],"type":"function"},{"constant":true,"inputs":[{"name":"_owner","type":"address"},{"name":"_spender","type":"address"}],"name":"allowance","outputs":[{"name":"remaining","type":"uint256"}],"type":"function"},{"anonymous":false,"inputs":[{"indexed":true,"name":"_from","type":"address"},{"indexed":true,"name":"_to","type":"address"},{"indexed":false,"name":"_value","type":"uint256"}],"name":"Transfer","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"_owner","type":"address"},{"indexed":true,"name":"_spender","type":"address"},{"indexed":false,"name":"_value","type":"uint256"}],"name":"Approval","type":"event"}],"userDoc":{"methods":{}},"developerDoc":{"methods":{}}}},"TokenInterface":{"code":"0x","info":{"source":"/// @title DigixDAO Token Contract.\n\ncontract TokenInterface {\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n\n    /// @return total amount of tokens\n    uint256 public totalSupply;\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return The balance\n    function balanceOf(address _owner) constant returns (uint256 balance);\n\n    /// @notice send `_value` tokens to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of tokens to be transfered\n    /// @return Whether the transfer was successful or not\n    function transfer(address _to, uint256 _value) returns (bool success);\n\n    /// @notice send `_value` tokens to `_to` from `_from` on the condition it is approved by `_from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of tokens to be transfered\n    /// @return Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens on its behalf\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of tokens to be approved for transfer\n    /// @return Whether the approval was successful or not\n    function approve(address _spender, uint256 _value) returns (bool success);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens of _owner that _spender is allowed to spend\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\ncontract Token is TokenInterface {\n\n  modifier noEther() {if (msg.value > 0) throw; _}\n\n  function transfer(address _to, uint256 _value) noEther returns (bool success) {\n    if (balances[msg.sender] >= _value && _value > 0) {\n      balances[msg.sender] -= _value;\n      balances[_to] += _value;\n      Transfer(msg.sender, _to, _value);\n      success = true;\n    } else {\n      success = false;\n    }\n    return success;\n  }\n\n  function transferFrom(address _from, address _to, uint256 _value) noEther returns (bool success) {\n    if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n      balances[_to] += _value;\n      balances[_from] -= _value;\n      allowed[_from][msg.sender] -= _value;\n      Transfer(_from, _to, _value);\n      success = true;\n    } else {\n      success = false;\n    }\n    return success;\n  }\n\n  function approve(address _spender, uint256 _value) returns (bool success) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  function balanceOf(address _owner) constant returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n    return allowed[_owner][_spender];\n  }\n}\n","language":"Solidity","languageVersion":"0.2.2","compilerVersion":"0.2.2","compilerOptions":"--bin --abi --userdoc --devdoc --add-std --optimize -o /var/folders/k3/0rzjczt16cg_0k4b9drzr6nm0000gn/T/solc017761134","abiDefinition":[{"constant":false,"inputs":[{"name":"_spender","type":"address"},{"name":"_value","type":"uint256"}],"name":"approve","outputs":[{"name":"success","type":"bool"}],"type":"function"},{"constant":true,"inputs":[],"name":"totalSupply","outputs":[{"name":"","type":"uint256"}],"type":"function"},{"constant":false,"inputs":[{"name":"_from","type":"address"},{"name":"_to","type":"address"},{"name":"_value","type":"uint256"}],"name":"transferFrom","outputs":[{"name":"success","type":"bool"}],"type":"function"},{"constant":true,"inputs":[{"name":"_owner","type":"address"}],"name":"balanceOf","outputs":[{"name":"balance","type":"uint256"}],"type":"function"},{"constant":false,"inputs":[{"name":"_to","type":"address"},{"name":"_value","type":"uint256"}],"name":"transfer","outputs":[{"name":"success","type":"bool"}],"type":"function"},{"constant":true,"inputs":[{"name":"_owner","type":"address"},{"name":"_spender","type":"address"}],"name":"allowance","outputs":[{"name":"remaining","type":"uint256"}],"type":"function"},{"anonymous":false,"inputs":[{"indexed":true,"name":"_from","type":"address"},{"indexed":true,"name":"_to","type":"address"},{"indexed":false,"name":"_value","type":"uint256"}],"name":"Transfer","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"_owner","type":"address"},{"indexed":true,"name":"_spender","type":"address"},{"indexed":false,"name":"_value","type":"uint256"}],"name":"Approval","type":"event"}],"userDoc":{"methods":{"approve(address,uint256)":{"notice":"`msg.sender` approves `_spender` to spend `_value` tokens on its behalf"},"transfer(address,uint256)":{"notice":"send `_value` tokens to `_to` from `msg.sender`"},"transferFrom(address,address,uint256)":{"notice":"send `_value` tokens to `_to` from `_from` on the condition it is approved by `_from`"}}},"developerDoc":{"methods":{"allowance(address,address)":{"params":{"_owner":"The address of the account owning tokens","_spender":"The address of the account able to transfer the tokens"},"return":"Amount of remaining tokens of _owner that _spender is allowed to spend"},"approve(address,uint256)":{"params":{"_spender":"The address of the account able to transfer the tokens","_value":"The amount of tokens to be approved for transfer"},"return":"Whether the approval was successful or not"},"balanceOf(address)":{"params":{"_owner":"The address from which the balance will be retrieved"},"return":"The balance"},"transfer(address,uint256)":{"params":{"_to":"The address of the recipient","_value":"The amount of tokens to be transfered"},"return":"Whether the transfer was successful or not"},"transferFrom(address,address,uint256)":{"params":{"_from":"The address of the sender","_to":"The address of the recipient","_value":"The amount of tokens to be transfered"},"return":"Whether the transfer was successful or not"}},"title":"DigixDAO Token Contract."}}}}